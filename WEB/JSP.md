## JSP

* JSP(Java Server Pages)
  
  * Dynamic 웹 페이지를 만들 수 있는 방법으로 제공하는 자바를 기반으로 하고 있는 스크립트 언어로 자바 엔터프라이즈 어플리케이션에서 UI 영역을 담당

* JSP 동작과정
  
  * 1. 서버에 클라이언트의 jsp 페이지 요청(request)
    
    2. jsp 컨테이너로 전송 : 웹 컨테이너로 jsp 파일을 넘기는데 이때 톰캣 서버가 웹 컨테이너의 역할을 수행
    
    3. jsp 파일 파싱 : 해달 jsp 파일이 처음 요청된 것이라면 파일을 파싱
    
    4. java 파일로 변환 : 새로운 자바 파일을 생성 (서블릿 클래스)
    
    5. *.class 파일 생성 : 서블릿 파일(java 파일)이 컴파일 되어 클래스 파일 생성
    
    6. 메모리에 로딩 : 클래스 파일은 메모리에 로딩
    
    7. html 전송 : 로딩된 클래스 파일에 대한 실행 결과를 웹 서버로 넘김. 웹 서버는 html 형태로 사용자에게 응답(response) 함
    
    8. 브라우저에 html 실행

* 서블릿(Servlet)
  
  * 서블릿은 java라는 언어로 웹 프로그램을 만들기 위한 기술로 웹 프로그래밍에서 클라이언트의 요청 request를 처리하고 그 결과를 다시 클라이언트에게 응답 response하는 클래스 -> MVC 모델에서 Controller 역할
  * 서블릿은 자바파일이라 웹 브라우저에 보여줄 수 있는 리소스가 아니기 때문에 웹에서 접근 가능한 형태(url, uri)로 접근하기 위해 서블릿과 url을 연결해주는 url 매핑이 필수 

:collision: MVC1 모델에서 서블릿은 controller 역할, jsp는 view 역할

* MVC (Model View Controller) : 디자인 패턴(코드를 짜는 방식)
  
  * Model : DB와 연동해 CRUD 작업을 하는 객체 -> DAO
  
  * View + Controller (현재)
    
    * main : Sysout(출력) / dao의 메서드를 호출(controller)
    
    * Servlet : controller / out.writer() -> 출력

* MVC 1동작과정
  
  * 1. 웹 브라우저에서 요청
    
    2. 요청을 jsp가 받아서 자바빈이나 서비스 클래스를 사용해서 웹 브라우저가 요청한 작업 처리
    
    3. 결과를 클라이언트에게 응답

* MVC2 모델
  
  * Model : 기존과 동일하게 DB와 연동해 CRUD 작업하는 DAO
  
  * View : client에게 응답해줄 페이지를 꾸며주는 역할 -> jsp
    
    - 클라이언트의 모든 요청값이 controller를 거치게끔 만들어 줄 것
  
  * Controller : 기능 담당 + 클라이언트의 요청 / 응답처리

* MVC2 동작과정
  
  * 1. 웹 브라우저에서 요청
    
    2. 요청을 서블릿이 받아서 로직 클래스를 통해 요청을 처리(비즈니스 로직에 알맞은 모델을 선택하여 처리)
    
    3. 포워딩을 통해 요청 흐름을 받은 JSP 페이지는 결과 화면을 생성
    
    4. 결과를 클라이언트에 응답

* MVC1 패턴과 MVC2 패턴의 비교
  
  * 뷰와 컨트롤러의 분할 여부
  
  * MVC1 모델은 뷰와 컨트롤러가 하나의 JSP페이지로 작성, MVC2 모델은 서블릿으로 요청을 받아서 알맞게 처리한 후에 JSP 페이지로 포워딩하는 형태로 작동
  
  * MVC1 패턴은 최근에는 거의 사용하지 않지만 소규모 프로젝트를 진행할 때는 오히려 MVC2 패턴보다 구조가 단순하여 구축이 쉽다, 하지만 그 규모가 커질 수록 유지보수에 약점을 보인다.
  
  * MVC2 패턴은 최근 거의 표준처럼 사용되는 패턴. 규모가 큰 프로젝트를 하기에 적합하고, 각 기능이 확실하게 분리되어 있어 유지보수에 상당한 이점을 보인다, 하지만 소규모 프로젝트를 진행함에 있어서 과도하게 구조가 복잡해질 수 있었지만 최근에는 프레임워크를 통해 이러한 단점은 보완되었다.

* MVC 패턴 사용 이유
  
  * 유지보수에서 상당히 유리함
  * -> MVC 패턴으로 잘 짜여진 웹 어플리케이션은 사용자에게 보여지는 부분(View)과 흐름 제어를 담당하는 부분(Controller), 비즈니스 로직을 수행하는 부분(Model)이 독립적으로 나눠져 있기 때문에 특정 부분을 수정하고자 하면, 그 부분만 열어서 수정하기에 상당히 용이함 

* EL(Expression Language) 
  
  * Servlet(controller)로부터 넘겨받은 request안에 있는 값을 꺼내서 사용하기 위해 필요한 언어

* ${key} : controller에서 setting 해줬던 key 값을 {} 안에 넘기면 그 key 값에 해당하는 값이 반환

* 배열/리스트 for문 돌리기 위해서 라이브러리 추가 필요
  
  * JSTL(Jsp / Java Tag Library)
  
  * -> script 영역이 아닌곳에서 for문 / if문을 사용할 수 있게 해줌
  
  * 라이브러리에 추가 후  사용하려는 jsp 파일 내에서 import 작업해주기
    
    -> <%@ taglib prefix="c" uri="http://java.sun.com/jsp/jstl/core" %> 
  
  * <c:forEach items = "for문을 돌릴 리스트/배열" var = "리스트/배열 각 인데스에 담겨있는 배열">

* session
  
  * 클라이언트(웹 브라우저)가 서버에 접속하는 순간 (첫 요청값을 보내는 순간)
  
  * -> 서버가 지금 접속한 클라이언트에 대한 식별값을 하나 생성함(session id)
  
  * -> 서버는 식별 값을 이용해 HTTPSession 객체(저장소)를 생성

* SHA (Secure Hash Algorithm)
  
  * 안전한 해시 알고리즘
  
  * 다양한 길이를 가진 데이터를 고정된 길이값으로 변환하는 알고리즘
  
  * 복호화(암호화된 데이터를 원본데이터로 되돌릴 수 없음)가 불가능한 단방향 암호화 기법
  
  * SHA512 -> 원본데이터를 128byte의 무작위의 데이터로 변환

* Cookie
  
  * 클라이언트와 서버가 연결을 시도한 흔적을 남겼다가, 후에 또 연결을 시도할 시 과거의 접속을 이어나가기 위해 흔적을 사용하는 방법
  * ex) 로그인 시 아이디 기억하기 체크하고 로그인했을때 로그아웃 후 다시 페이지 들어갔을때 마지막에 입력된 아이디값이 자동으로 셋팅
